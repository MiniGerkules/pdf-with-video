\documentclass[russian]{lecture-notes}

\usepackage{misccorr}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{systeme}
\usepackage{hyperref}
\usepackage{timestamps}
\usepackage{svg}
\usepackage{algorithm}
\usepackage{algpseudocode}

\title{НОД. \\Расширенный алгоритм Евклида.}

\lecturer{Сергей Николаевич Поздняков}

\notesauthor{В.В.Пронин}

\date{12 марта 2018}

\begin{document}

\youtubevideo{nIirf97dJnI}
\maketitle

\timestamp{6:00}
\section{Делимость целых чисел}

Важно понимать, что деление и делимость - это два разных понятия: операция и отношение. В первом случае при делении чисел $a$ и $b$ в результате получаем число.
\[a \ / \ b \longrightarrow  \text{число}\]
Во втором случае результатом будет являться не число, а логическое значение "да" или "нет" (отношение делимости описывается словами "$a$ делится на $b$", или "$b$ делит $a$").
\begin{figure}[h!]
    \centering
    $
    \begin{matrix}
        a \ \vdots \ b
        \\
        b \ | \ a
    \end{matrix}
    $
    $\longrightarrow$
    $
    \begin{cases}
        \text{да} \\
        \text{нет}
    \end{cases}
    $
\end{figure}

\timestamp{7:30}

\begin{definition}
    Целое число $a$ делится на число $b \ (b  \neq 0) \stackrel{def}{\Longleftrightarrow}$ остаток от деления $a$ на $b$ равен $0$.
\end{definition}

Это определение можно свести к другому:
\[a = b \cdot q + r, \quad
0 \leq r < |b|, тогда\]
\[r = 0 \ \Leftrightarrow \ \underline{a = b \cdot q}\]

Поэтому говорят, что $a$ делится на $b$, если существует такое целое число $q$, что $a$ равняется $b \cdot q$

\timestamp{9:50}
\textbf{Свойства делимости:}
\begin{itemize}
    \item [1)] $a \ \vdots \ d$, $b \ \vdots \ d$ $\rightarrow a - k \cdot b \ \vdots\ d$

    \begin{note}
        $a,b,d,k \in \mathbb{Z}$
    \end{note}
    \label{sv:1}
\end{itemize}

\timestamp{10:20}
\textit{Доказательство.}

\begin{equation*}
\left.\begin{gathered}
a \ \vdots \ d \ \ \Leftrightarrow \  \text{сущ. }  q_1:\ a = \ q_1 \cdot d
    \\
    b \ \vdots \ d \ \ \Leftrightarrow \  \text{сущ. }  q_2:\ b = \ q_2 \cdot d
\end{gathered}\right\}
\Rightarrow
\end{equation*}


\[a - kb = q_1 \cdot d - k \cdot q_2 \cdot d = \underbrace{(q_1 - kq_2)}_q \cdot \ d = q \cdot d \ \Leftrightarrow \ a - kb \ \vdots \ d\]

\begin{itemize}
    \item [2)] $a \ \vdots \ b, b \ \vdots \ c \rightarrow a \ \vdots \ c$ (транзитивность делимости)
\end{itemize}

\timestamp{12:30}
\begin{proof}
    Необходимо привести самим.
\end{proof}

\begin{itemize}
    \item [3)] $a \ \vdots \ b, b \ \vdots \ a \rightarrow |a| = |b|$
\end{itemize}

\timestamp{12:50}
\begin{proof}
    Необходимо привести самим.
\end{proof}

\newpage

\timestamp{13:50}
\section{ Наибольший общий делитель (НОД)}

Допустим, что у нас есть набор целых неотрицательных чисел $\{a_1,a_2,\ldots,a_n\}$, при этом не все числа в наборе равны нулю.

Обратимся к первому свойству делимости. Назовем вычитание из одного целого числа $(a)$ другого целого $(b)$, умноженного на некоторый целый коэффициент $(k)$, элементарной операцией. Первое свойство делимости говорит нам о том, что если целые числа $a$ и $b$ имели какой-то общий делитель, то и числа полученные в результате элементарной операции $(a - kb \text{ и } b)$ также будут иметь этот общий делитель.

Вернемся к нашему набору, над которым мы будем совершать такие элементарные операции: брать два ненулевых числа и из большего вычитать меньшее, умноженное на $k$. Число $k$ будем брать максимальным, при котором результат $a - k \cdot b$ не будет отрицательным, Благодаря этому числа набора будут уменьшаться максимально быстро.

Данный алгоритм закончит свою работу, когда в наборе не найдется двух ненулевых чисел, то есть все числа кроме одного будут равны нулю. Заметим, что делители чисел набора сохранятся после всех этих преобразований. Поэтому когда останется одно ненулевое число, то оно и будет наибольшим общим делителем набора.

Таким образом, следующий алгоритм находит наибольший общий делитель данного набора чисел.

\timestamp{18:20}
Ниже представлено несколько алгоритмов, отличающихся правилом выбора пары чисел.

\begin{algorithm}[h!]
	\caption{Алгоритм нахождение НОД}
	\begin{algorithmic}[1]
	    \While{в наборе есть два ненулевых числа}
	    \State Выбрать $a_i \geq a_j > 0$
	    \State $a_i := a_j - ka_j$, $k$ - такое, что результат неотрицательный
	    \EndWhile
	    \State $d := max \{a_1,\ldots,a_n\} = \{0,\ldots,d,\ldots,0\}$
	\end{algorithmic}
	\label{alg:1}
\end{algorithm}

\begin{note}
    Если, как говорилось выше, выбирать k максимальным, при котором результат вычитания остается неотрицательным, алгоритм можно оптимизировать, заменив "$a_i := a_j - ka_j$, $k$ - такое, что результат неотрицательный" \ на "$a_i$ : заменить остатком от деления на $a_j$".
\end{note}

\timestamp{20:35}
\textbf{Инварианты цикла алгоритма нахождение НОД}

\begin{itemize}
    \item[1)] \emph{Все числа неотрицательны.}
\end{itemize}

\begin{proof}
    Алгоритм не изменяет это свойство, потому что мы всегда искуственно его соблюдаем, когда заменяем одно число на другое неотрицательное.
\end{proof}

\timestamp{21:00}
\begin{itemize}
    \item[2)] \emph{Множество делителей не меняется.}
    \[D = D'\]
\end{itemize}

$D$ - множество делителей исходного набора чисел до начала выполнения операций в теле цикла. $D'$ - множество делителей набора после их выполнения.

\timestamp{22:00}
\begin{proof}
Изначально у нас был набор

\[a_1,\ldots,a_i,\ldots,a_j,\ldots,a_n\]
после одного шага цикла у нас получился модифицированный набор,
\[a_1' = a_1,\ldots,a_i'=a_i-ka_j,\ldots,a_j' = a_j,\ldots,a_n' = a_n\]
в котором поменялся только $a_i'=a_i-ka_j$. Если у чисел исходного набора был какой-то делитель, то у всех чисел нового набора, которые не изменились, он же и останется. Необходимо доказать, что он будет и у числа $a_i'$.

Пусть $d$ - делитель исходного набора, то есть \[a_i \ \vdots \ d, a_j \ \vdots \ d \rightarrow a_i'=a_i-ka_j \ \vdots \ d\] по первому свойству делимости.
\end{proof}
\timestamp{24:30}
Так мы доказали, что любой делитель исходного набора будет также делителем измененного набора.

Далее нужно доказать что при выполнении элементарного преобразования не добавляются новые делители.

\timestamp{25:05}
\begin{proof}
Пусть $d$ - делитель модифицированного набора; докажем, что он будет делителем исходного.

Проведем рассуждения в обратной последовательности. Пусть у чисел модифицированного набора есть общий делитель $d$. Число $a_i'$  модифицированного набора равно $a_i - ka_j$  в обозначениях исходного, а число $a_j'$ модифицированного набора совпадает с числом $a_j$ исходного. Поэтому из $a_i'=a_i-ka_j$  получаем $a_i'=a_i-ka_j'$ или, что то же самое, ${a_i=a_i'+ka_j'}$  которое будет иметь число $d$ делителем \hyperref[sv:1]{по первому свойству делимости}. Остальные числа у модифицированного и у исходного набора одинаковы. Поэтому любой делитель модифицированного набора будет также делителем исходного.
\end{proof}

\timestamp{32:30}

\begin{remark}
    Для того, чтобы определить наибольший общий делитель чисел можно взять все общие делители чисел и выбрать из них наибольший. Однако при этом у нас кроме отношения делимости возникает потребность использования ещё одного отношения "больше-меньше". В следующем семестре мы будем изучать автоматическое доказательство теорем. Увидим, что трудоемкость этих алгоритмов велика. Поэтому при формулировке теорем нужно использовать как можно меньше различных сущностей (этот принцип достаточно общий и называется бритвой Оккама) т..к. их количество экспоненциально влияет на количество вариантов, которые программа должна будет перебрать, чтобы доказать теорему.  Более выгодно будет определить наибольший общий делитель как тот, который делится на все остальные общие делители чисел, чтобы избавиться от отношения "больше-меньше".
\end{remark}

Если вернуться к нашему алгоритму, то можно увидеть, что из всего множества делителей у нас осталось только одно число, которое делится на все остальные делители набора чисел. То есть все делители набора являются делителями наибольшего общего делителя.

\timestamp{35:40}
Для нахождения еще одного инварианта цикла алгоритма \ref{alg:1} обратимся к следующей задаче.

\timestamp{36:00}
\begin{problem}
    Даны числа: $12$ и $9$. Какое множество получится, если выполнять над ними операции сложения и вычитания в произвольном количестве?
\end{problem}
\noindent \textbf{Ответ:} числа, кратные трём.

Множество таких чисел можно записать как:

\[M = \{12x+9y \ | \ x, y \in \mathbb{Z}\} = \{3d \ | \ d \in \mathbb{Z}\}\]

Если рассмотреть множество комбинаций линейного набора, то окажется, что оно тоже не меняется при элементарных преобразованиях.

\timestamp{38:50}
\begin{itemize}
    \item[3)] Множество линейных комбинаций $L$ набора чисел не будет меняться при элементарных преобразованиях.

    \emph{$L = \{a_1x_1,+\ldots+a_nx_n \ \text{где} \ x_1,\ldots,x_n \in \mathbb{Z} \}$}
\end{itemize}
\[L'=L\]
\begin{note}
    $L$ - множество линейных комбинаций. $L'$ - аналог $L$, только в процессе работы алгоритма.
\end{note}

\begin{proof}
    Необходимо привести самим.
\end{proof}

\timestamp{41:15}

Исходя из данного инварианта, можно сделать вывод о том, что линейная кобминация набора ($a_1, \ldots, a_n$) будет равняться линейной комбинации, состоящей из нулей и одного наибольшего делителя.

\[L (a_1,\ldots a_n ) = L (0,\ldots d,\ldots,0 )\]

Если эти множества равны, значит для каждого элемента одного из множеств можно найти соответствующее представление в другом. Если в правом множестве есть $d$, значит в левом множестве найдутся такие коэффициенты, что будет выполнено следующее равенство

\begin{equation*}
    a_1x_1 + \ldots + a_nx_n = d
\end{equation*}

\timestamp{43:05}
\begin{theorem}[о линейном представлении НОД]
    Если $d = \text{НОД} (a_1, \ \ldots, \ a_n)$, то найдутся такие целые коэффициенты $x_1, \ \dotsc, \ x_n$, что ${a_1x_1 + \ldots a_nx_n = d}$.
\end{theorem}

\timestamp{47:15}
Рассмотрим детализацию работы не самого эффективного алгоритма \ref{alg:2} для набора из двух чисел, построенного на основе \ref{alg:1} для $k = 1$.

\textbf{Пример.}
\begin{figure}[h!]
    \centering
    \begin{tabular}{| c | c |}
    \hline
    $a$ = 34 & $b$ = 12\\
    \hline
        34 & 12\\
        22 & 12 \\
        10 & 12 \\
        10 & 2 \\
        8 & 2 \\
        6 & 2 \\
        4 & 2 \\
        2 & 2 \\
        0 & 2 \\
    \hline
    \end{tabular}
\end{figure}

\timestamp{48:50}
\begin{algorithm}[H]
	\caption{Алгоритм нахождение НОД}
	\begin{algorithmic}[1]
	    \While{$a \neq 0 \text{ and } b \neq 0$}\
    	    \If{$a \geq b$}
    	        \State $a := a - b$
    	    \EndIf
    	    \If{$a < b$}
    	        \State $b := b - a$
    	    \EndIf
	    \EndWhile
	    \State $d := max \{a;b\}$
	\end{algorithmic}
	\label{alg:2}
\end{algorithm}

Данный алгоритм можно усовершенствовать, добавив циклы, в которых мы сразу получаем остаток от деления большего числа на меньшее.


\begin{algorithm}[H]
	\caption{Улучшенный алгоритм нахождение НОД}
	\begin{algorithmic}[1]
	    \While{$a \neq 0 \text{ and } b \neq 0$}\
    	    \While{$a \geq b$}
    	        \State $a := a - b$
    	    \EndWhile
    	    \While{$a < b$}
    	        \State $b := b - a$
    	    \EndWhile
	    \EndWhile
	    \State $d := max \{a;b\}$
	\end{algorithmic}
	\label{alg:3}
\end{algorithm}

\textbf{Пример.}
\begin{figure}[h!]
    \centering
    \begin{tabular}{| c | c |}
    \hline
    $a$ = 34 & $b$ = 12\\
    \hline
        34 & 12\\
        22 & 12 \\
        10 & 12 \\
        10 & 2 \\
        8 & 2 \\
        6 & 2 \\
        4 & 2 \\
        2 & 2 \\
        0 & 2 \\
    \hline
    \end{tabular}
\end{figure}

Заменив циклы, которые позволяют нам находить остаток от деления одного числа на другое повторяющимся вычитанием, на вычисление остатка (операция mod) мы получим алгоритм Евклида.

\timestamp{52:30}
\begin{algorithm}[h!]
	\caption{Алгоритм Евклида}
	\begin{algorithmic}[1]
	    \While{$a \neq 0 \text{ and } b \neq 0$}\
    	    \If{$a \geq b$}
    	        \State $a := a \text{ mod } b$
    	    \EndIf
    	    \If{$a < b$}
    	        \State $b := b \text{ mod } a$
    	    \EndIf
	    \EndWhile
	    \State $d := max \{a;b\}$
	\end{algorithmic}
\end{algorithm}

\newpage

\timestamp{55:05}
\begin{example} Работу данного алгоритма удобно представлять в виде таблицы.
        \begin{figure}[h!]
            \begin{tabular}{cccccc}
            \cline{2-6}
            \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{34} & \multicolumn{1}{l|}{12} & \multicolumn{1}{l|}{10} & \multicolumn{1}{l|}{2} & \multicolumn{1}{l|}{0} \\ \cline{2-6}
            \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{}   & \multicolumn{1}{l|}{}   & \multicolumn{1}{l|}{2}  & \multicolumn{1}{l|}{1} & \multicolumn{1}{l|}{5} \\ \cline{2-6}
            1 шаг: & a & b & r &  &  \\
            2 шаг: &  & b & a & r &  \\
            3 шаг: &  &  & a & b & r \\
            4 шаг: &  &  &  & b & a
            \end{tabular}
    \end{figure}
\end{example}

Когда цикл завершается, мы выбираем наибольшее из $a$ и $b$. Это число и будет НОД $(a;b)$.

\newpage

\timestamp{1:00:10}
\section{Расширенный алгоритм Евклида}

\begin{problem}
    Как налить один литр в бочку неограниченных размеров с помощью двух вёдер объемами 17 и 12 литров, если количество воды не ограничено?
\end{problem}

\begin{note}
    Вливать ведра объемом $17$ и $12$ литров друг в друга нельзя, а зачерпывать можно только полные ведра.
\end{note}

\begin{figure}[h!]
  \centering
  \includesvg{123.svg}

  Рисунок к задаче.
\end{figure}

Договоримся, что черпать будем полными ведрами и из ведра в ведро не переливать, хотя в дальнейшем можно заметить, что последнее условие несущественно. Заметим, что если мы налили воду, например, ведром $12$ литров, а через некоторое время этим же ведром отлили $12$ литров, то эти две операции компенсировали друг друга и их можно просто не делать. Таким образом, можно считать, что  одним ведром мы будем только наливать воду, а другим только отливать.

Задача сведется к уравнению вида
\[17x + 12y = 1\]
где знаки перед $x$ и $y$ зависят от того, наливаем мы или выливаем какое-то количество вёдер.

Вернемся к инварианту, связанному с линейными комбинациями. Левую часть уравнения можно рассматривать как линейную комбинацию $17$ и $12$. Нас интересуют коэффициенты, при которых она равно единице.

Отсюда может возникнуть мысль использовать алгоритм Евклида для решения данной задачи.

\timestamp{1:04:40}

Для начала представим наши "ведра" в виде векторов:

\[A = (1,0) = 1 \cdot 17 + 0 \cdot 12 = 17\]
\[B = (0,1) = 0 \cdot 17 + 1 \cdot 12 = 12\]

Фактически это линейные комбинации.

Перейдем к решению нашего уравнения через алгоритм нахождение НОД. Слева решение с числами, справа же с векторами. Мысленно выполните действия алгоритма \ref{alg:2} сначала над числами, а потом над представляющими их векторами. Обратите внимание, что алгоритм \ref{alg:3} для этого не годится, так как в нем есть деление, а операция деления над векторами не определена.

\begin{center}
    \begin{tabular}{|c|c|}
        \hline
        17 & 12 \\
        5 & 12 \\
        5 & 2 \\
        1 & 2 \\
        \hline
    \end{tabular}
    \quad
    \begin{tabular}{|c|c|}
        \hline
        (1;0) & (0;1) \\
        (1;-1) & (0;1) \\
        (1;-1) &  (-2;3)\\
        (5;-7) &  (-2;3) \\
        \hline
    \end{tabular}
\end{center}

Остановимся, когда достигнем нужного нам числа $1$, ему соответствует вектор $(5;-7)$. Если подставить координаты данного вектора в изначальное уравнение вместо $x$ и $y$, то получится:
\[17 \cdot 5 + (-7) \cdot 12 = 85 - 84 = 1\]

то есть чтобы получить $1$ литр в бочке, нам нужно $7$ раз налить в него воду ведром объемом $17$ литров и $5$ раз вычерпнуть из него воду ведром объемом $12$ литров.

\timestamp{1:08:50}
Выполненные выше действия удобно записывать в форме протокола в горизонтальной таблице

\begin{figure}[h!]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|}
    \hline
        17 & 12 & 5 & 2 & \fbox{1} & 0 \\
    \hline
         &  & 1 & 2 & 2 & 2\\
    \hline
        1 & 0 & 1 & -2 & \fbox{5} & -12 \\
    \hline
        0 & 1 & -1 & 3 & \fbox{-7} & 17 \\
    \hline
    \end{tabular}
\end{figure}

\begin{note}
    Первые два числа в первой строке - это коэфициенты перед $x$ и $y$ в нашем уравнении. Дальше в этой строке идут остатки после элементарных преобразований.

    Во второй строке стоят неполные частные.

    Третья и четвертая строка предназначены для представления чисел в виде векторов.

    Вектор
    $
    \begin{pmatrix}
    1  \\
    0
    \end{pmatrix}
    $
    в первом столбце таблицы обозначает, что для получения числа $17$ нам необходимо $1$ раз влить ведро объемом $17$ литров и $0$ раз влить ведро объемом $12$ литров. Аналогично можно интерпретировать и другие вектора, ставшие частью столбиков таблицы.
\end{note}

Модифицируем алгоритм Евклида, добавив в него вектора, а также упростив его, заменяя после каждого шага результаты так, чтобы всегда делить $a$ на $b$. На первый взгляд кажется, что это создаст проблему деления меньшего числа на большее, однако это добавит лишь один лишний шаг. Действительно, если $a < b$, то при делении неполное частное будет равно нулю, а остаток совпадет с делимым $(a)$. После этого $a$ и $b$ обменяются местами и далее всегда большее число $a$ будет делиться на меньшее $b$.

\timestamp{1:12:30}
\begin{algorithm}[h!]
	\caption{Алгоритм Евклида}
	\begin{algorithmic}[1]
	    \Statex Инициализация:
	    \State $(x_a;y_a) := (1;0); \ (x_b;y_b):=(0;1)$
	
	    \Statex
	
	    \While{$a \neq 0$ и $b \neq 0$}\
    	    \State $q := a \text{ div } b$
    	    \State $r := a - qb$ ; $(x_r;y_r) := (x_a;y_a) - q \cdot (x_b;y_b)$
    	    \State $a := b$ ; $(x_a;y_a) := (x_b;y_b)$
    	    \State $b:= r$ ; $(x_b;y_b) := (x_r;y_r)$
	    \EndWhile
	    \Statex Ответ:$(x_a;y_a)$.
	\end{algorithmic}
\end{algorithm}

\newpage

\section{Бинарный алгоритм Евклида}

В заключение, рассмотрим еще один алгоритм, который выгодно применять для нахождения НОД чисел в двоичной записи.

\timestamp{1:18:30}
\begin{algorithm}[h!]
	\caption{Бинарный алгоритм Евклида}
	\begin{algorithmic}[1]
	    \Statex Инициализация:
		\State $d := 1$ \Comment{$d$ - переменная для хранения НОД}
		\Statex
		\While{($a \ \vdots \  2$ and $b \ \vdots \ 2$)}
		    \State $b := b/2$; \quad $a := a/2$; \quad $d := d \cdot 2$
		\EndWhile \Comment{Данный цикл сдвигает числа $a$ и $b$ вправо, избавляя их от нулей в конце. В это же время он сдвигает $d$ влево.}
		
		\Statex
		\Comment{После окончания предыдущего цикла, обязательно одно число будет делиться на $2$, а другое нет. Однако если одно делится, а второе не делится, то двойки из его разложения на простые множители можно  выбросить, т.к. они уже не будут общими делителями. Это достигается делением этого числа на $2$ или сдвигами его двоичной записи вправо, что делается в следующем цикле.}
		\Statex
		\While{($a \neq 0$ и $b \neq 0$)} \Comment{Данное условие позволяет нам остановится, когда найдется НОД}
    		\While{$a \ \vdots \ 2$}
    		    \State $a := a/2$
    		\EndWhile
    		\While{$b \ \vdots \ 2$}
    		    \State $b := b/2$
    		\EndWhile
    		\Statex
    		\Comment{Когда останется два нечетных числа, происходит вычитание меньшего из большего, чтобы получить четное число, которое можно будет опять делить на два.}
    		\Statex
    		\If{$a \leq b$}
    		    \State $a := a - b$
    		\Else
    		    \State $b := b - a$
    		\EndIf
		\EndWhile
		\State $ d:= d \cdot max\{a;b\}$
	\end{algorithmic}
\end{algorithm}

\end{document} 
